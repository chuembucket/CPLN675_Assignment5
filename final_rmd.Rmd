---
title: "Urban Growth Modeling in Delaware County, PA"
author: "Charlie Huemmler & Kate Tanabe"
date: "2023-05-06"
output: 
  rmdformats::downcute:
    code_folding: hide
---

```{=html}
<style>
  .superbigimage {
    overflow-x:scroll;
    white-space: nowrap;
  }

  .superbigimage img {
    max-width: none;
  }
</style>
```

## Introduction 
Understanding where development is likely to take place is crucial for urban planners and decision makers. Regional land use planning requires both supply and demand-side insights to inform how demand interacts with current supply and future goals. Planners are responsible for navigating the trade-offs between economic growth, environmental sustainability, and community objectives.  Including future land development predictions in planning analyses allows planners to understand infrastructure needs, advocate for certain types of growth, and incentive development that meets the community’s goals. 

### Motivation 
This project analyzes Delaware County’s historic patterns of development to predict areas that are likely to be developed to inform regional planners of the current and future demands. This information can be used by Delaware County planners when considering regional growth patterns, prioritizing and allocating new developments, and understanding how developments fit within goals for the future. 

This model uses national land cover and land cover change datasets from 2009 and 2019 to predict 2029 development patterns.  We build a binary logistic model using variables including distance to highways, distance to current development, distance to train lines, and demographic information. We hypothesize that future land development is a function of these variables. 

We also use this model to create an allocation procedure for urban growth based on population change, development demand, and supply of land in 2029.  The allocation procedure prioritizes future development based on community values by using the model’s outcome, which is probability of development. Planners can use the allocation procedure to understand how different land use and development scenarios will impact the community.

### Development Scenarios 
We use two scenarios to predict future land development in our analysis. The first scenario looks at demand-side change based on the population projections for Delaware County. The population predictions will inform planners of where demand for development will be greater. The second scenario examines the incorporation of a hypothetical new development, the extension of SEPTA’s Westchester Branch from Wawa west to the county border This scenario explores how the addition of a new development will change potential allocation. 

## Set Up 
```{r load_packages, message=FALSE, warning=FALSE, results = "hide"}
library(tidyverse)
library(sf)
library(raster)
library(knitr)
library(kableExtra)
library(tidycensus)
library(tigris)
library(FNN)
#library(QuantPsyc) # JE Note: in R 4.1, QuantPsyc package not available.
library(caret)
library(yardstick)
library(pscl)
library(plotROC) 
library(ggrepel)
library(pROC)
library(grid)
library(gridExtra)
library(viridis)
#library(igraph)
library(mapview)
library(here)
library(terra)
library(cowplot)
plotTheme <- theme(
  plot.title =element_text(size=12),
  plot.subtitle = element_text(size=8),
  plot.caption = element_text(size = 6),
  axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
  axis.text.y = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  # Set the entire chart region to blank
  panel.background=element_blank(),
  plot.background=element_blank(),
  #panel.border=element_rect(colour="#F0F0F0"),
  # Format the grid
  panel.grid.major=element_line(colour="#D0D0D0",size=.2),
  axis.ticks=element_blank())

mapTheme <- function(base_size = 8, title_size = 10, small_size = 6) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = title_size, colour = "black", hjust = 0.5),
    plot.subtitle=element_text(size = base_size, colour = "black", hjust = 0.5, face="italic"),
    plot.caption=element_text(size = small_size, colour = "black", hjust = 0.5),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    strip.text.x = element_text(size = base_size),
    strip.text.y = element_text(size = base_size),
    strip.background = element_rect(colour="transparent", fill="transparent"),
    legend.title = element_text(size = small_size),
    legend.text = element_text(size = small_size),
    legend.key.size = unit(0.25, "cm"))
}

colors <- c("#2F4858", "#1372A4", "#86BBD8", "#A8C686","#E75E15")

#this function converts a column in to quintiles. It is used for mapping.
quintileBreaks <- function(df,variable) {
    as.character(quantile(df[[variable]],
                          c(.01,.2,.4,.6,.8),na.rm=T))
}

#This function can be used to convert a polygon sf to centroids xy coords.
xyC <- function(aPolygonSF) {
  as.data.frame(
    cbind(x=st_coordinates(st_centroid(aPolygonSF))[,1],
          y=st_coordinates(st_centroid(aPolygonSF))[,2]))
} 

#this function convert a raster to a data frame so it can be plotted in ggplot
rast <- function(inRaster) {
  data.frame(
    xyFromCell(inRaster, 1:ncell(inRaster)), 
    value = getValues(inRaster)) }

datafolder <- file.path(here() %>% dirname(), 'assn5data')


palette2 <- c("#41b6c4","#253494")
palette4 <- c("#a1dab4","#41b6c4","#2c7fb8","#253494")
palette5 <- c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494")
palette10 <- c("#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4",
               "#4eb3d3","#2b8cbe","#0868ac","#084081","#f7fcf0")

```

## Data Wrangling 
We move onto data wrangling and start by importing land cover data from the US Geological Survey's National Land Cover Database. We specifically pulled 2008 land cover, 2019 land cover, and land cover change for Delaware County.
```{r load_data, warning = FALSE, message = FALSE, results = "hide"}

lc_2008 <- raster(paste(datafolder, "delco_2008_final.tif", sep = '/')) 


lc_2019 <- raster(paste(datafolder, "delco_2019_Clip_Clip.tif", sep = '/')) 
lc_change <- raster(paste(datafolder, "delco_change_final.tif", sep = '/')) 
crs(lc_change) <- crs(lc_2008)


delco <- 
  get_decennial(geography = 'county', state = 'PA', year = 2020, county = 'Delaware', variables = 'P1_005N', geometry = T) %>% st_transform(crs = st_crs(lc_change))



```

```{r plot_msa1, warning= FALSE, message= FALSE}

LCnames <-c("None",
  "Water",
  "Urban",
  "Wetland within Class",
  "Herbaceous Wetland",
  "Agriculture within Class",
  "Cultivated Crop",
  "Hay/Pasture",
  "Rangeland herbaceous and shrub",
  "Barren",
  "Forest",
  "Woody Wetland")


lc_changespat <- as(lc_change, "SpatRaster")
LCcodes <- unique(lc_change)

nlcdcols_c <- data.frame(coltab(lc_changespat))
nlcdcols_c <- nlcdcols_c[LCcodes + 1,]
LCcolors <- rgb(red = nlcdcols_c$red,
                green = nlcdcols_c$green,
                blue = nlcdcols_c$blue,
                names = as.character(LCcodes),
                maxColorValue = 255)
ggplot()+
  geom_sf(data=delco) +
  geom_raster(data=rast(lc_change) %>% na.omit %>% filter(value > 1),
              aes(x,y,fill=as.factor(value))) +
  scale_fill_manual(name = "Land cover",
                    values = LCcolors,
                    labels = LCnames,
                    na.translate = FALSE) +   labs(title = "Land Cover Change, 2008-2019???") +
  mapTheme()
  


```





We classify the land cover change data in order to identify what areas have experienced development change since 2008. Here, we reclassify so the raster data so that each area is assigned a value of 0, meaning no development has occurred, or 1, meaning development has occurred. This binary development change will be our dependent variable for our analysis and modeling. 

```{r, warning = FALSE, message = FALSE}
reclassMatrix <- matrix(c(
  0, 0,
  1, 0,
  2, 1,
  3, 0,
  4, 0,
  5, 0,
  6, 0,
  7, 1, 
  8, 1, 
  9, 1, 
  10, 1, 
  11, 1, 
  12, 1, 
  Inf, 0
), ncol=2, byrow=T)

reclassMatrix
```



```{r, warning = FALSE, message = FALSE}
lc_change2 <- 
  reclassify(lc_change,reclassMatrix)

lc_change2[lc_change2 < 1] <- NA

names(lc_change2) <- "lc_change"


ggplot() +
  geom_sf(data=delco) +
  geom_raster(data=rast(lc_change2) %>% na.omit, 
              aes(x,y,fill=as.factor(value))) +
  scale_fill_viridis(discrete=TRUE, name ="Land Cover\nChange") + 
  labs(title="Development Land Use Change") +
  mapTheme()
```

### Creating the Fishnet
We use a fishnet that covers Delaware County for our analysis. This will allow us to assign values for each of the features in our analysis to cells within the fishnet. This fishnet uses a 500-meter resolution. 


```{r delco_fishnet start, warning = FALSE, message = FALSE}
delco_fishnet <- 
  st_make_grid(delco, 500, square = F) %>%
  st_sf()

delco_fishnet <-
  delco_fishnet[delco,]
```



```{r, warning = FALSE, message= FALSE}
ggplot() +
  geom_sf(data=delco_fishnet) +
  labs(title="Fishnet, 500 Meter Resolution") +
  mapTheme()
```


We then aggregate the land cover change data with the fishnet so we can see which cells have had development since 2008. The fishnet with land cover change is presented below. 

```{r, warning = FALSE, message = FALSE}
changePoints <-
  rasterToPoints(lc_change2) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(delco_fishnet))

fishnet <- 
  aggregate(changePoints, delco_fishnet, sum) %>%
  mutate(lc_change = ifelse(is.na(lc_change),0,1),
         lc_change = as.factor(lc_change))

ggplot() +
  geom_sf(data=delco) +
  geom_sf(data=fishnet, aes(fill=lc_change), color = NA) +
  scale_fill_manual(values = colors,
                      labels=c("No Change","New Development"),
                      name = "") +
  labs(title = "Land Cover Development Change", subtitle = "As fishnet centroids") +
  mapTheme()
```

## 2.3. Land Cover in 2008

Below we plot the land cover by type in Delaware County for 2008. 

### Land Cover in 2019
We also present the land cover by type in Delaware County for 2019.

```{r}
#https://www.mrlc.gov/data/legends/national-land-cover-database-class-legend-and-description


LCnames <-c("NA",
  "Water",
  "DevelopedOpen",
  "DevelopedLow",
  "DevelopedMed",
  "DevelopedHigh",
  "Barren",
  "DeciduousForest",
  "EvergreenForest",
  "MixedForest",
  "ShrubScrub",
  "GrassHerbaceous",
  "PastureHay",
  "CultCrops",
  "WoodyWetlands",
  "EmergentHerbWet")


lc_2008spat <- as(lc_2008, "SpatRaster")
LCcodes <- unique(lc_2008)

nlcdcols08 <- data.frame(coltab(lc_2008spat))
nlcdcols08 <- nlcdcols08[LCcodes + 1,]
LCcolors <- rgb(red = nlcdcols08$red,
                green = nlcdcols08$green,
                blue = nlcdcols08$blue,
                names = as.character(LCcodes),
                maxColorValue = 255)


```



```{r, warning = FALSE, message = FALSE}

p1<-ggplot() +
  geom_sf(data=delco) +
  geom_raster(data=rast(lc_2008) %>% na.omit %>% filter(value > 0), 
              aes(x,y,fill=as.factor(value))) +
  scale_fill_manual(name = "Land cover",
                    values = LCcolors,
                    labels = LCnames,
                    na.translate = FALSE) +  
  labs(title = "Land Cover Classification", subtitle = 2008) +
  mapTheme()

p2<-ggplot()+
  geom_sf(data=delco) +
  geom_raster(data=rast(lc_2019) %>% na.omit %>% filter(value > 0), 
              aes(x,y,fill=as.factor(value))) +
  scale_fill_manual(name = "Land cover",
                    values = LCcolors,
                    labels = LCnames,
                    na.translate = FALSE) + 
  labs(title = "", subtitle = "2019") +
  mapTheme()+
  theme(legend.position = 'none')

legend <- get_legend(p1)
p1<-p1 +  theme(legend.position = 'none')

# move the legend to the right
ggdraw(plot_grid(p1, p2, legend, ncol=3, align='v', rel_widths=c(1, 1, .4)))

```

## Feature Engineering
In this section, we engineer additional features that will be used as independent variables for our modeling. Features include land cover type, population data, distance to highways, distance to railways, and spatial lag of development. 

### Land Cover Type Categories
We further refine the land cover types into categories in order to understand where development happens most often. Here we recategorize the land use classification so that any open space plus any low, medium, or high intensity development is considered developed. We categorize the remaining land cover types into the following groups: forest, farm, woodlands, water, or other undeveloped land. 

```{r, warning = FALSE, message = FALSE}
developed <- lc_2008 == 21 | lc_2008 == 22 | lc_2008 == 23 | lc_2008 == 24
forest <- lc_2008 == 41 | lc_2008 == 42 | lc_2008 == 43 
farm <- lc_2008 == 81 | lc_2008 == 82 
wetlands <- lc_2008 == 90 | lc_2008 == 95 
otherUndeveloped <- lc_2008 == 52 | lc_2008 == 71 | lc_2008 == 31 
water <- lc_2008 == 11

names(developed) <- "developed"
names(forest) <- "forest"
names(farm) <- "farm"
names(wetlands) <- "wetlands"
names(otherUndeveloped) <- "otherUndeveloped"
names(water) <- "water"
```

Next, each raster is aggregated to the fishnet by way of a function called `aggregateRaster`. Here, the process used above to To do this, a function is created below that loops through a list of rasters, converts the _ith_ raster to points, filters only points that have value of `1` (ie. is the _ith_ land cover type), and then aggregates to the fishnet.

Here is the function.

```{r, warning = FALSE, message = FALSE}
aggregateRaster <- function(inputRasterList, theFishnet) {
  #create an empty fishnet with the same dimensions as the input fishnet
  theseFishnets <- theFishnet %>% dplyr::select()
  #for each raster in the raster list
  for (i in inputRasterList) {
  #create a variable name corresponding to the ith raster
  varName <- names(i)
  #convert raster to points as an sf
    thesePoints <-
      rasterToPoints(i) %>%
      as.data.frame() %>%
      st_as_sf(coords = c("x", "y"), crs = st_crs(theFishnet)) %>%
      filter(.[[1]] == 1)
  #aggregate to the fishnet
    thisFishnet <-
      aggregate(thesePoints, theFishnet, length) %>%
      mutate(!!varName := ifelse(is.na(.[[1]]),0,1))
  #add to the larger fishnet
    theseFishnets <- cbind(theseFishnets,thisFishnet)
  }
  #output all aggregates as one large fishnet
   return(theseFishnets)
  }
```

```{r, warning = FALSE, message = FALSE}
theRasterList <- c(developed,forest,farm,wetlands,otherUndeveloped,water)

aggregatedRasters <-
  aggregateRaster(theRasterList, delco_fishnet) %>%
  dplyr::select(developed,forest,farm,wetlands,otherUndeveloped,water) %>%
  mutate_if(is.numeric,as.factor)

aggregatedRasters %>%
  gather(var,value,developed:water) %>%
  st_cast("POLYGON") %>%    #just to make sure no weird geometries slipped in
  mutate(X = xyC(.)$x,
         Y = xyC(.)$y) %>%
  ggplot() +
    geom_sf(data=delco) +
    geom_point(aes(X,Y, colour=as.factor(value))) +
    facet_wrap(~var) +
    scale_colour_manual(values = colors,
                        labels=c("Other","Land Cover"),
                        name = "") +
    labs(title = "Land Cover Types, 2001",
         subtitle = "As fishnet centroids") +
   mapTheme()
```

### Census Data
We also include population and population change variables in our analysis given that these population metrics impact demand for development. We import census population data for each of the census tracts in Delaware County. We present 2008 and 2019 populations for the county by tract and by fishnet below. 

```{r load_key, warning = FALSE, eval = FALSE}
#census_api_key("YOUR KEY GOES HERE", overwrite = TRUE)
census_api_key("4bbe4bead4e5817f6a6b79e62c5bea69e77f1887", overwrite = TRUE)
```


```{r, warning = FALSE, message = FALSE, results = "hide"}
# Specify which variable(s) you would like to grab. Here, only one (Total Population) is listed, but you could add more to the call.
acs_vars <- c("B02001_001E")

#haven't updated any of the acs stuff 

# Using "tract" as the geography and 2019 as the year, download data data for the Houston MSA counties listed.
delcoPop09 <- get_acs(geography = "tract", 
                        variables = acs_vars, 
                        year = 2009,
                        state = "PA", 
                        geometry = TRUE, 
                        output = "wide",
                        county=c("Delaware")) %>%
                rename(pop2009 = B02001_001E) %>%
                dplyr::select(-starts_with("B"))

# Make sure to transform to the crs of the fishnet!
delcoPop09  <- delcoPop09  %>%
  st_transform(st_crs(delco_fishnet))

```

```{r, warning = FALSE, message = FALSE, results = "hide"}
# Specify which variable(s) you would like to grab. Here, only one (Total Population) is listed, but you could add more to the call.
acs_vars <- c("B02001_001E")

# Using "tract" as the geography and 2019 as the year, download data data for the Houston MSA counties listed.
delcoPop19 <-  get_acs(geography = "tract", 
                        variables = acs_vars, 
                        year = 2019,
                        state = "PA", 
                        geometry = TRUE, 
                        output = "wide",
                        county=c("Delaware")) %>%
                rename(pop2019 = B02001_001E) %>%
                dplyr::select(-starts_with("B"))# Make sure to transform to the crs of the fishnet!
delcoPop19 <- delcoPop19 %>%
  st_transform(st_crs(delco_fishnet))

```

Both years of census data are then plotted.

<div class="superbigimage">
```{r, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
grid.arrange(
ggplot() +
  geom_sf(data = delcoPop09, aes(fill=factor(ntile(pop2009,5))), colour=NA) +
  scale_fill_manual(values = palette5,
                    labels=quintileBreaks(delcoPop09,"pop2009"),
                   name="Quintile\nBreaks") +
  labs(title="Population, Delware County: 2009") +
  mapTheme(),

ggplot() +
  geom_sf(data = delcoPop19, aes(fill=factor(ntile(pop2019,5))), colour=NA) +
  scale_fill_manual(values = palette5,
                    labels=quintileBreaks(delcoPop19,"pop2019"),
                   name="Quintile\nBreaks") +
  labs(title="Population, Delaware County: 2019") +
  mapTheme(), ncol=2)
```

```{r, warning = FALSE, message = FALSE}
delco_fishnet <-
  delco_fishnet %>%
  rownames_to_column("fishnetID") %>% 
  mutate(fishnetID = as.numeric(fishnetID)) %>%
  dplyr::select(fishnetID)

fishnetPopulation09 <-
  st_interpolate_aw(delcoPop09["pop2009"], delco_fishnet, extensive=TRUE) %>%
  as.data.frame(.) %>%
  rownames_to_column(var = "fishnetID") %>%
  left_join(delco_fishnet %>%
              mutate(fishnetID = as.character(fishnetID)),
            ., by=c("fishnetID"='fishnetID')) %>% 
  mutate(pop2009 = replace_na(pop2009,0)) %>%
  dplyr::select(pop2009)

fishnetPopulation19<-
  st_interpolate_aw(delcoPop19["pop2019"],delco_fishnet, extensive=TRUE) %>%
  as.data.frame(.) %>%
  rownames_to_column(var = "fishnetID") %>%
  left_join(delco_fishnet %>%
              mutate(fishnetID = as.character(fishnetID)),
            ., by=c("fishnetID"='fishnetID')) %>% 
  mutate(pop2019 = replace_na(pop2019,0)) %>%
  dplyr::select(pop2019)

fishnetPopulation <- 
  cbind(fishnetPopulation09,fishnetPopulation19) %>%
  dplyr::select(pop2009,pop2019) %>%
  mutate(pop_Change = pop2019 - pop2009)
```

```{r, warning = FALSE, message = FALSE, fig.height = 8, fig.width= 11}
grid.arrange(
ggplot() +
  geom_sf(data=delcoPop19, aes(fill=factor(ntile(pop2019,5))),colour=NA) +
  scale_fill_manual(values = palette5,
                    labels=substr(quintileBreaks(delcoPop19,"pop2019"),1,4),
                   name="Quintile\nBreaks") +
  labs(title="Population, Delaware County: 2019",
       subtitle="Represented as tracts; Boundaries omitted") +
  mapTheme(),

ggplot() +
  geom_sf(data=fishnetPopulation, aes(fill=factor(ntile(pop2019,5))),colour=NA) +
  scale_fill_manual(values = palette5,
                   labels=substr(quintileBreaks(fishnetPopulation,"pop2019"),1,4),
                   name="Quintile\nBreaks") +
  labs(title="Population, Delaware County: 2019",
       subtitle="Represented as fishnet gridcells; Boundaries omitted") +
  mapTheme(), ncol=2)
```

### Existing Development & Infrastructure
In addition to land types and census data, we incorporate spatial variables related to existing development and infrastructure. Here we create the following features: distance to highways, distance to railways, municipalities, and spatial lag to development. Spatial lag takes the distance to existing development into considerations, as we hypothesize that new development is a function of the previous variables plus the pattern of existing development. 


```{r, warning = FALSE, message = FALSE, results = "hide"}

delcoRoads <- read_sf("C:/Users/cchue/Documents/GIS/delcodata/streets.shp")  

delcoHighways <- delcoRoads %>% st_transform(st_crs(lc_change)) %>% filter(RoadClass %in% c("INTERSTATE", "MAJOR"))

delcoRail <- delcoRoads %>% st_transform(st_crs(lc_change)) %>% filter(RoadClass %in% c("RAIL"))




```



```{r, warning = FALSE, message = FALSE}
emptyRaster <- lc_change
emptyRaster[] <- NA

highway_raster <- 
  as(delcoHighways,'Spatial') %>%
  rasterize(.,emptyRaster)

highway_raster_distance <- distance(highway_raster)
names(highway_raster_distance) <- "distance_highways"

highwayPoints <-
  rasterToPoints(highway_raster_distance) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(delco_fishnet))

highwayPoints_fishnet <- 
  aggregate(highwayPoints, delco_fishnet, mean) %>%
  mutate(distance_highways = ifelse(is.na(distance_highways),0,distance_highways))

ggplot() +
  geom_sf(data=delco) +
  geom_sf(data=highwayPoints_fishnet, aes(fill=factor(ntile(distance_highways,5))),color = NA) +
  scale_fill_manual(values = palette5,
                      labels=substr(quintileBreaks(highwayPoints_fishnet,"distance_highways"),1,8),
                      name="Quintile\nBreaks") +
  geom_sf(data=delcoHighways, colour = "red") +
  labs(title = "Distance to Highways",
       subtitle = "As fishnet centroids; Highways visualized in red") +
  mapTheme()
```

```{r trains}

septa_rr_line <- read_sf(paste(datafolder, "rail_existing_clip.shp", sep = '/')) %>% 
  st_transform(crs = st_crs(delco)) 

septa_rr_line_ext <- read_sf(paste(datafolder, "rail_merge_clip.shp", sep = '/')) %>% 
  st_transform(crs = st_crs(delco)) 



septa_rr_line_addition <- read_sf(paste(datafolder, "rail_extension_clip.shp", sep = '/')) %>% 
  st_transform(crs = st_crs(delco)) 



septa_rr_line_ext <- septa_rr_line_ext[delco,]

septa_rr_line <- septa_rr_line[delco,]


septa_rr_station <- read_sf("C:/Users/cchue/Documents/GIS/Transit/transitshp/regionalrailstats.shp")  

septa_trolley_line <- read_sf("C:/Users/cchue/Documents/GIS/Transit/transitshp/trolley.shp")  
septa_trolley_station <- read_sf("C:/Users/cchue/Documents/GIS/Transit/transitshp/trolleystops.shp")  


ggplot()+
  geom_sf(data=delco, fill ="#86BBD8",color = "transparent") +
  geom_sf(data = septa_rr_line, line = 'dashed', color ="red")+
  labs(title = "Existing Regional Rail in Delaware County") +
  mapTheme()+
  theme(legend.position = 'none')

```

```{r, warning = FALSE, message = FALSE}
emptyRaster <- lc_change
emptyRaster[] <- NA

#for existing rail
rr_raster <- 
  as(septa_rr_line,'Spatial') %>%
  rasterize(.,emptyRaster)

rr_raster_distance <- distance(rr_raster)
names(rr_raster_distance) <- "distance_rr"

rrPoints <-
  rasterToPoints(rr_raster_distance) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(delco_fishnet))

rrPoints_fishnet <- 
  aggregate(rrPoints, delco_fishnet, mean) %>%
  mutate(distance_rr = ifelse(is.na(distance_rr),0,distance_rr))

#for future rail extension/2030 predictions
rr_raster2 <- 
  as(st_zm(septa_rr_line_addition),'Spatial') %>%
  rasterize(.,emptyRaster)

rr_raster_distance2 <- distance(rr_raster2)
names(rr_raster_distance2) <- "distance_rr2"

rrPoints2 <-
  rasterToPoints(rr_raster_distance2) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(delco_fishnet))

rrPoints2_fishnet <- 
  aggregate(rrPoints2, delco_fishnet, mean) %>%
  mutate(distance_rr2 = ifelse(is.na(distance_rr2),0,distance_rr2))

#back to existing
rrPoints_fishnet <- 
  aggregate(rrPoints, delco_fishnet, mean) %>%
  mutate(distance_rr = ifelse(is.na(distance_rr),0,distance_rr))

ggplot() +
  geom_sf(data=delco) +
  geom_sf(data=rrPoints_fishnet, aes(fill=factor(ntile(distance_rr,5))),color = NA) +
  scale_fill_manual(values = palette5,
                      labels=substr(quintileBreaks(rrPoints_fishnet,"distance_rr"),1,8),
                      name="Quintile\nBreaks") +
  geom_sf(data=septa_rr_line, colour = "red") +
  labs(title = "Distance to Regional Rail",
       subtitle = "As fishnet centroids; current Regional Rail visualized in red") +
  mapTheme()
```
### New Development: Extension of the SEPTA's Westchester Brand
For the supply-side development scenario, we propose extending the Westchester Brand from Wawa west to the county boarder as shown below. 

```{r}
ggplot()+
  geom_sf(data=delco, fill ="#86BBD8", color = "transparent") +
  geom_sf(data = septa_rr_line, line = 'dashed', color ="red")+
  geom_sf(data = septa_rr_line_addition, line = 'dashed', color ="black", width = 5)+
  labs(title = "Proposed Extension of Regional Rail in Delaware County",
       subtitle="Existing rail displayed in red, proposed extension displayed in black") +
  mapTheme()+
  theme(legend.position = 'none')
```


```{r municplaitiets}

delcoMunic <- read_sf("C:/Users/cchue/Documents/GIS/delcodata/municipals.shp") %>% st_transform(st_crs(delco_fishnet)) %>% 
  mutate(munic_area = as.numeric(st_area(.)))



delcoMunic_fishnet <- st_join(delco_fishnet %>% st_centroid(), delcoMunic, join = st_within) %>% st_drop_geometry() %>% 
  full_join(., delco_fishnet) %>% st_sf() %>% 
  dplyr::select(c('Name','fishnetID','munic_area'))

grid.arrange(
ggplot(delcoMunic_fishnet)+
  geom_sf(aes(fill = munic_area), color = NA)+
  mapTheme(),
ggplot(delcoMunic_fishnet)+
  geom_sf(aes(fill = Name), color = NA)+
  theme(legend.position = 'none')+
  mapTheme(),
ncol = 2
)
```


```{r, warning = FALSE, message = FALSE}
nn_function <- function(measureFrom,measureTo,k) {
  #convert the sf layers to matrices
  measureFrom_Matrix <-
    as.matrix(measureFrom)
  measureTo_Matrix <-
    as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
    output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}
```

```{r, warning = FALSE, message = FALSE}
fishnet$lagDevelopment <-
    nn_function(xyC(fishnet),
                xyC(filter(aggregatedRasters,developed==1)),
                2)

ggplot() +
  geom_sf(data=fishnet, 
             aes(fill=factor(ntile(lagDevelopment,5))), color = NA) +
  scale_fill_manual(values = palette5,
                     labels=substr(quintileBreaks(fishnet,"lagDevelopment"),1,7),
                     name="Quintile\nBreaks") +
  labs(title = "Spatial Lag to 2010 Development",
       subtitle = "As fishnet centroids") +
  mapTheme()
```


### Final Dataset
Below we combine all of the features we engineered and map them to our fishnet.
```{r, warning = FALSE, message = FALSE}
dat <- 
  cbind(
    fishnet, highwayPoints_fishnet, rrPoints_fishnet, fishnetPopulation, aggregatedRasters, delcoMunic_fishnet) %>%
  dplyr::select(lc_change, developed, forest, farm, wetlands, otherUndeveloped, water,
                pop2009, pop2019, pop_Change, distance_highways, distance_rr, lagDevelopment, Name, munic_area) %>%
  mutate(developed10 = ifelse(lc_change == 1 & developed == 1, 0, developed)) %>%
  filter(water == 0) 
```

## Exploratory Analysis
We now continue into the exploratory analysis process. In this section, we explore the association between development change and our spatial and population variables. We examine the ways in which these variables interact with the fishnet cells that experienced new development.  

### Continuous Variables
Below we explore the continuous variables: distance to highways, distance to railways, and spatial lag to development. We can see that new development occurs in cells that are closer to highways, railways, and other development. 
```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(distance_highways,distance_rr,lagDevelopment, lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable) +
    scale_fill_manual(values = palette2,
                      labels=c("No Change","New Development"),
                      name="") +
    labs(title="New Development as a Function of the Continuous Variables") +
    plotTheme 
```
### Population Variables
We also examine the relationship between new development and population variables. New development in Delaware County occurs in cells where population change is higher than other cells. This follows our hypothesis that higher rates of population change leads to more development. Interestingly, 2009 and 2019 population show a different relationship. We can see that new development seems to occur in cells with lower population in Delaware County.
```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(pop2009,pop2019,pop_Change,lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable, scale='free') +
    scale_fill_manual(values = palette2,
                      labels=c("No Change","New Development"),
                      name="") +
    labs(title="New Development as a Function of Factor Variables") +
    plotTheme
```
## Land Conversion Rates
We present a table of conversion rates for each land cover category below. The table below indicates that forest and wetlands are most often converted to development in Delaware County. 
```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(lc_change:otherUndeveloped,developed) %>%
  gather(Land_Cover_Type, Value, -lc_change, -geometry) %>%
   st_set_geometry(NULL) %>%
     group_by(lc_change, Land_Cover_Type) %>%
     summarize(n = sum(as.numeric(Value))) %>%
     ungroup() %>%
    mutate(Conversion_Rate = paste0(round(100 * n/sum(n), 2), "%")) %>%
    filter(lc_change == 1) %>%
  dplyr::select(Land_Cover_Type,Conversion_Rate) %>%
  kable() %>% kable_styling(full_width = F)
```

## Predicting for 2030
We now move into the modeling section of the analysis. We developed seven logistic regression models to predict where development will occur for 2019 and 2029/2030. We discuss the models' ability to predict accurate results and the implications for planners in the following sections. 

### Modeling
As mentioned, we build seven models using a combination of the following variables: land cover type, spatial lag to development population in 2009, population in 2019, population change, distance to highways, and distance to railroads. We used a 50% split to separate our data into two parts: a training set and a test set.
```{r, warning = FALSE, message = FALSE}
set.seed(3456)
trainIndex <- 
  createDataPartition(dat$developed, p = .50,
                                  list = FALSE,
                                  times = 1)
datTrain <- dat[ trainIndex,]
datTest  <- dat[-trainIndex,]

Model1 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped, 
              family="binomial"(link="logit"), data = datTrain)

Model2 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment, 
              family="binomial"(link="logit"), data = datTrain)
              
Model3 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop2009, 
              family="binomial"(link="logit"), data = datTrain)          
              
Model4 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop2009 + 
              pop2019, 
              family="binomial"(link="logit"), data = datTrain)              
            
Model5 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change, 
              family="binomial"(link="logit"), data = datTrain)              
              
Model6 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change + 
              distance_highways, 
              family="binomial"(link="logit"), data = datTrain) 

Model7 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change + 
              distance_highways + distance_rr,
              family="binomial"(link="logit"), data = datTrain) 


modelList <- paste0("Model", 1:7)
map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("Model",1:7)) %>%
  gather(Model,McFadden) %>%
  ggplot(aes(Model,McFadden)) +
    geom_bar(stat="identity") +
    labs(title= "McFadden R-Squared by Model") +
    plotTheme
```
### Predictions
```{r, warning = FALSE, message = FALSE}
predsForMap <-         
  dat %>%
    mutate(probs = predict(Model7, dat, type="response") ,
           Threshold_5_Pct = as.factor(ifelse(probs >= 0.05 ,1,0)),
           Threshold_17_Pct =  as.factor(ifelse(probs >= 0.17 ,1,0)),
           Threshold_50_Pct =  as.factor(ifelse(probs >= 0.5 ,1,0))) %>%
    dplyr::select(lc_change,Threshold_5_Pct,Threshold_17_Pct,Threshold_50_Pct) %>%
    gather(Variable,Value, -geometry) %>%
    st_cast("POLYGON")
```
### Predictions Based on Threshold
```{r, warning = FALSE, message = FALSE}
options(yardstick.event_first = FALSE)

testSetProbs <- 
  data.frame(class = datTest$lc_change,
             probs = predict(Model7, datTest, type="response")) 

testSetProbs <- 
  testSetProbs %>% 
  mutate(predClass_05 = as.factor(ifelse(testSetProbs$probs >= 0.05 ,1,0)),
         predClass_17 = as.factor(ifelse(testSetProbs$probs >= 0.17 ,1,0)),
         predClass_50 = as.factor(ifelse(testSetProbs$probs >= 0.50 ,1,0)),
         predClass_60 = as.factor(ifelse(testSetProbs$probs >= 0.50 ,1,0)),
         predClass_70 = as.factor(ifelse(testSetProbs$probs >= 0.50 ,1,0))) 

testSetProbs %>%
   dplyr::select(-probs) %>%
   gather(Variable, Value, -class) %>%
  group_by(Variable) %>%
   summarize(Sensitivity = round(yardstick::sens_vec(class,factor(Value)),2),
             Specificity = round(yardstick::spec_vec(class,factor(Value)),2),
             Accuracy = round(yardstick::accuracy_vec(class,factor(Value)),2)) %>% 
   kable() %>%
   kable_styling(full_width = F)
```


```{r }

ggplot(testSetProbs, aes(probs)) +
  geom_density(aes(fill=class), alpha=0.5) +
  scale_fill_manual(values = palette2,
                    labels=c("No Change","New Development")) +
  labs(title = "Histogram of test set predicted probabilities",
       x="Predicted Probabilities",y="Density") +
  plotTheme
```

```{r, warning = FALSE, message= FALSE, fig.height = 6, fig.width= 8}
ggplot() +
  geom_sf(data=predsForMap, aes(fill=Value), color =NA) +
  facet_wrap(~Variable) +
  scale_fill_manual(values = palette2, labels=c("No Change","New Development"),
                      name="") +
  labs(title="Development Predictions - Low Threshold") + 
  mapTheme()
```
### Predictions Based on Confusion Matrix
```{r, warning = FALSE, message = FALSE}
ConfusionMatrix.metrics <-
  dat %>%
    mutate(probs = predict(Model6, dat, type="response") ,
           Threshold_5_Pct = as.factor(ifelse(probs >= 0.05 ,1,0)),
           Threshold_17_Pct =  as.factor(ifelse(probs >= 0.17 ,1,0))) %>%
    mutate(TrueP_05 = ifelse(lc_change  == 1 & Threshold_5_Pct == 1, 1,0),
           TrueN_05 = ifelse(lc_change  == 0 & Threshold_5_Pct == 0, 1,0),
           TrueP_17 = ifelse(lc_change  == 1 & Threshold_17_Pct == 1, 1,0),
           TrueN_17 = ifelse(lc_change  == 0 & Threshold_17_Pct == 0, 1,0)) %>%
    dplyr::select(., starts_with("True")) %>%
    gather(Variable, Value, -geometry) %>%
    st_cast("POLYGON") 

ggplot(data=ConfusionMatrix.metrics) +
  geom_sf(aes(fill = as.factor(Value)), color = NA) +
  facet_wrap(~Variable) +
  scale_fill_manual(values = palette2, labels=c("Correct","Incorrect"),
                       name="") +
  labs(title="Development Predictions - Low Threshold") + mapTheme()
```

## Generalizability & Spatial Cross Validation
```{r, warning = FALSE, message = FALSE}
spatialCV <- function(dataFrame, uniqueID, dependentVariable, modelName) {

#initialize a data frame 
endList <- list()

#create a list that is all the spatial group unqiue ids in the data frame (ie counties)    
  uniqueID_List <- unique(dataFrame[[uniqueID]])  
  x <- 1
  y <- length(uniqueID_List)
  
#create a counter and while it is less than the number of counties...  
  while(x <= y) 
  {
#call a current county    
    currentUniqueID <- uniqueID_List[x]
#create a training set comprised of units not in that county and a test set of units
#that are that county
    training <- dataFrame[ which(dataFrame[[uniqueID]] != uniqueID_List[x]),]
    testing <- dataFrame[ which(dataFrame[[uniqueID]] == uniqueID_List[x]),]
#create seperate xy vectors
    trainingX <- training[ , -which(names(training) %in% c(dependentVariable))]
    testingX <- testing[ , -which(names(testing) %in% c(dependentVariable))]
    
    trainY <- training[[dependentVariable]]
    testY <- testing[[dependentVariable]]
#Calculate predictions on the test county as part of a data frame including the observed
#outcome and the unique county ID    
   thisPrediction <- 
     data.frame(class = testY,
                probs = predict(modelName, testingX, type="response"),
                county = currentUniqueID) 

#Row bind the predictions to a data farme
   endList <- rbind(endList, thisPrediction)
#iterate counter    
    x <- x + 1 
  } 
#return the final list of counties and associated predictions  
  return (as.data.frame(endList))
}

dat_cv <- dat %>% mutate(Name = ifelse(!is.na(Name),Name,'Edge') )

spatialCV_counties <-
  spatialCV(dat_cv,"Name","lc_change", Model6) %>%
  mutate(predClass = as.factor(ifelse(probs >= 0.5 ,1,0)))

spatialCV_metrics <-
  spatialCV_counties %>% 
    group_by(county) %>% 
    summarize(Observed_Change = sum(as.numeric(as.character(class))),
              Sensitivity = round(yardstick::sens_vec(class,predClass),2),
              Specificity = round(yardstick::spec_vec(class,predClass),2),
              Accuracy = round(yardstick::accuracy_vec(class,predClass),2)) 

spatialCV_metrics %>%
  kable() %>%
  kable_styling(full_width = F)
```

## Predicting Land Cover Demand for 2030
```{r, warning = FALSE, message = FALSE}
dat <-
  dat %>%
  mutate(lagDevelopment = nn_function(xyC(.), xyC(filter(.,developed10 == 1)),2))
```

### Population Projections
```{r, eval=FALSE, warning = FALSE, message = FALSE}
dat %>% mutate(Name = ifelse(!is.na(Name),Name,'Edge') )

muniPopulation_2030 <- 
  data.frame(
   Name = 
     c("Aldan Borough","Aston Township", "Bethel Township","Brookhaven Borough", "Chadds Ford Township", "Chester City", "Chester Heights Borough", "Chester Township", "Clifton Heights Borough", "Collingdale Borough", "Colwyn Borough", "Concord Township", "Darby Borough", "Darby Township", "East Lansdowne Borough", "Eddystone Borough", "Edgmont Township", "Folcroft Borough", "Glenolden Borough", "Haverford Township", "Landsdowne Borough", "Lower Chichester Township", "Marcus Hook Borough", "Marple Township", "Media Borough", "Middletown Township", "Millbourne Borough","Morton Borough", "Nether Providence Township", "Newton Township", "Norwood Borough", "Parkslide Borough", "Prospect Park Borough", "Radnor Township", "Ridley Park Borough", "Ridley Township", "Rose Valley Borough", "Rutledge Borough", "Sharon Hill Borough", "Springfield Township", "Swarthmore Borough", "Thornbury Township", "Tinicum Township", "Trainer Borough", "Upland Borough", "Upper Chichester Township", "Upper Darby Township", "Uppery Providence Township", "Yeadon Borough"),
   muni_projection_2030 = 
     c(4137, 17137, 10142, 8308, 3978, 31988, 2688, 9679, 6535, 8795, 2304, 16580, 11882, 28332, 2679, 2666, 3684, 6447, 7046, 51881, 10625, 3665, 2552, 24550, 5391, 17792, 1168, 2727, 13861, 4145, 5931, 2184, 6112, 32266, 7104, 29300, 903, 811, 5793, 24130, 6331, 8508,4273, 1751, 2734, 17416, 82464, 21180, 11472)) %>% 
  right_join(
     dat %>%
       st_drop_geometry() %>%
       group_by(Name) %>%
       summarize(muni_pop2009 = round(sum(pop2009))))

muniPopulation_2030_1 <- muniPopulation_2030 %>%
  group_by(Name) %>%
  summarize(muni_pop2030 = round(mean(muni_projection_2030)))
colnames(muniPopulation_2030_1)[1] = "Name"

muniPopulation_2030 <- left_join(muniPopulation_2030, muniPopulation_2030_1)
muniPopulation_2030 <- muniPopulation_2030 %>%
  dplyr::select(Name, muni_pop2009, muni_pop2030)

muniPopulation_2030 %>%
  gather(Variable,Value, -Name) %>%
  ggplot(aes(reorder(Name,-Value),Value)) +
  geom_bar(aes(fill=Variable), stat = "identity", position = "dodge") +
  scale_fill_manual(values = palette2,
                    labels=c("2008","2030"),
                    name="Population") +
  labs(title="Population Change by County: 2008 - 2030",
       x="County", y="Population") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  plotTheme

```

## Development Demand in 2030
```{r}
# dat_infill <-
#   dat %>%
#   #calculate population change
#     left_join(muniPopulation_2030) %>%
#     mutate(proportion_of_county_pop = pop2009 / county_population_2010,
#            pop_2020.infill = proportion_of_county_pop * county_projection_2020,
#            pop_Change = round(pop2020.infill - pop2010),2) %>%
#     dplyr::select(-county_projection_2020, -county_population_2010, 
#                   -proportion_of_county_pop, -pop2020.infill) %>%
#   #predict for 2020
#     mutate(predict_2020.infill = predict(Model6,. , type="response"))
# 
# dat_infill %>%
#   ggplot() +  
#   geom_point(aes(x=xyC(dat_infill)[,1], y=xyC(dat_infill)[,2], colour = factor(ntile(predict_2020.infill,5)))) +
#   scale_colour_manual(values = palette5,
#                     labels=substr(quintileBreaks(dat_infill,"predict_2020.infill"),1,4),
#                     name="Quintile\nBreaks") +
#   geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
#   labs(title= "Development Demand in 2020: Predicted Probabilities") +
#   mapTheme()
```